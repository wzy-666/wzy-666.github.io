<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenCV cv::watershed 源码解读</title>
    <link href="/2020/10/28/OpenCV-cv-watershed-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/2020/10/28/OpenCV-cv-watershed-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在Opencv中watershed函数是这样定义的：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cv::watershed</span> <span class="hljs-params">(InputArray <span class="hljs-built_in">image</span>,</span></span><span class="hljs-function"><span class="hljs-params">                    InputOutputArray markers)</span></span></code></pre><blockquote><p><em>Performs a marker-based image segmentation using the watershed algorithm.<br>The function implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in [163].</em>  </p></blockquote><p>其中比较重要的是：opencv中的watershed分割算法是基于marker的，因此其具有较强交互能力。<br>一般情况下 image 是三通道8位BGR图像，maekers 是单通道有符号32位图像（int32）  </p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1-遍历marker中的像素点，寻找边缘点-计算其的梯度，根据梯度大小放入优先队列"><a href="#1-遍历marker中的像素点，寻找边缘点-计算其的梯度，根据梯度大小放入优先队列" class="headerlink" title="1. 遍历marker中的像素点，寻找边缘点,计算其的梯度，根据梯度大小放入优先队列"></a>1. 遍历marker中的像素点，寻找边缘点,计算其的梯度，根据梯度大小放入优先队列</h3><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">size</span>.<span class="hljs-built_in">height</span><span class="hljs-number">-1</span>; i++ )&#123;    img += istep; mask += mstep;    <span class="hljs-keyword">for</span>( j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">size</span>.<span class="hljs-built_in">width</span><span class="hljs-number">-1</span>; j++ )    &#123;        <span class="hljs-keyword">int</span>* m = mask + j;        <span class="hljs-keyword">if</span>( m[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> ) m[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// m[-1] m[0] m[1] 分别是左像素、本像素、右像素 m[-mstep] m[mstep] 分别是上像素 下像素</span>        <span class="hljs-keyword">if</span>( m[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; (m[<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> || m[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> || m[-mstep] &gt; <span class="hljs-number">0</span> || m[mstep] &gt; <span class="hljs-number">0</span>) )         <span class="hljs-comment">// 如果本像素为0，而周围像素不为0，本像素为边缘点</span>        &#123;            <span class="hljs-comment">// Find smallest difference to adjacent markers</span>            <span class="hljs-keyword">const</span> uchar* ptr = img + j*<span class="hljs-number">3</span>;            <span class="hljs-keyword">int</span> idx = <span class="hljs-number">256</span>, t;            <span class="hljs-keyword">if</span>( m[<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> )                c_diff( ptr, ptr - <span class="hljs-number">3</span>, idx );            <span class="hljs-keyword">if</span>( m[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> )            &#123;                c_diff( ptr, ptr + <span class="hljs-number">3</span>, t );                idx = ws_min( idx, t );            &#125;            <span class="hljs-keyword">if</span>( m[-mstep] &gt; <span class="hljs-number">0</span> )            &#123;                c_diff( ptr, ptr - istep, t );                idx = ws_min( idx, t );            &#125;            <span class="hljs-keyword">if</span>( m[mstep] &gt; <span class="hljs-number">0</span> )            &#123;                c_diff( ptr, ptr + istep, t );                idx = ws_min( idx, t );            &#125;            <span class="hljs-comment">// Add to according queue</span>            assert( <span class="hljs-number">0</span> &lt;= idx &amp;&amp; idx &lt;= <span class="hljs-number">255</span> );            ws_push( idx, i*mstep + j, i*istep + j*<span class="hljs-number">3</span> );            m[<span class="hljs-number">0</span>] = IN_QUEUE;        &#125;    &#125;&#125;</code></pre><h3 id="2-按优先级从队列里取出像素点，对该像素进行分类，并将该像素点周围的没有放入过队列的空像素放入队列"><a href="#2-按优先级从队列里取出像素点，对该像素进行分类，并将该像素点周围的没有放入过队列的空像素放入队列" class="headerlink" title="2. 按优先级从队列里取出像素点，对该像素进行分类，并将该像素点周围的没有放入过队列的空像素放入队列"></a>2. 按优先级从队列里取出像素点，对该像素进行分类，并将该像素点周围的没有放入过队列的空像素放入队列</h3><blockquote><p>分类依据是：根据周围的像素点的label，如果周围只有一种label那么将该像素点设为此label，如果周围有多种label，那么将此像素点设为WATERSHED(<strong>分水岭边界</strong>)。  </p></blockquote><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(;;)&#123;    <span class="hljs-keyword">int</span> mofs, iofs;    <span class="hljs-keyword">int</span> lab = <span class="hljs-number">0</span>, t;    <span class="hljs-keyword">int</span>* m;    <span class="hljs-keyword">const</span> uchar* ptr;    <span class="hljs-comment">// Get next node</span>    ws_pop( active_queue, mofs, iofs );    <span class="hljs-comment">// Calculate pointer to current pixel in input and marker image</span>    m = mask + mofs;    ptr = img + iofs;    <span class="hljs-comment">// Check surrounding pixels for labels</span>    <span class="hljs-comment">// to determine label for current pixel</span>    <span class="hljs-comment">// 根据该点附近的label判断该点的label，如果该点附近label不同，那么将该点设为分水岭WSHED</span>    t = m[<span class="hljs-number">-1</span>]; <span class="hljs-comment">// Left</span>    <span class="hljs-keyword">if</span>( t &gt; <span class="hljs-number">0</span> ) lab = t;    t = m[<span class="hljs-number">1</span>]; <span class="hljs-comment">// Right</span>    <span class="hljs-keyword">if</span>( t &gt; <span class="hljs-number">0</span> )    &#123;        <span class="hljs-keyword">if</span>( lab == <span class="hljs-number">0</span> ) lab = t;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( t != lab ) lab = WSHED;    &#125;    t = m[-mstep]; <span class="hljs-comment">// Top</span>    <span class="hljs-keyword">if</span>( t &gt; <span class="hljs-number">0</span> )    &#123;        <span class="hljs-keyword">if</span>( lab == <span class="hljs-number">0</span> ) lab = t;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( t != lab ) lab = WSHED;    &#125;    t = m[mstep]; <span class="hljs-comment">// Bottom</span>    <span class="hljs-keyword">if</span>( t &gt; <span class="hljs-number">0</span> )    &#123;        <span class="hljs-keyword">if</span>( lab == <span class="hljs-number">0</span> ) lab = t;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( t != lab ) lab = WSHED;    &#125;    <span class="hljs-comment">// Set label to current pixel in marker image</span>    assert( lab != <span class="hljs-number">0</span> );    m[<span class="hljs-number">0</span>] = lab;    <span class="hljs-keyword">if</span>( lab == WSHED )        <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">// Add adjacent, unlabeled pixels to corresponding queue</span>    <span class="hljs-comment">// 将该像素点周围的没有放入过队列的空像素放入队列</span>    <span class="hljs-keyword">if</span>( m[<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> )    &#123;        c_diff( ptr, ptr - <span class="hljs-number">3</span>, t );        ws_push( t, mofs - <span class="hljs-number">1</span>, iofs - <span class="hljs-number">3</span> );        active_queue = ws_min( active_queue, t );        m[<span class="hljs-number">-1</span>] = IN_QUEUE;    &#125;    <span class="hljs-keyword">if</span>( m[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> )    &#123;        c_diff( ptr, ptr + <span class="hljs-number">3</span>, t );        ws_push( t, mofs + <span class="hljs-number">1</span>, iofs + <span class="hljs-number">3</span> );        active_queue = ws_min( active_queue, t );        m[<span class="hljs-number">1</span>] = IN_QUEUE;    &#125;    <span class="hljs-keyword">if</span>( m[-mstep] == <span class="hljs-number">0</span> )    &#123;        c_diff( ptr, ptr - istep, t );        ws_push( t, mofs - mstep, iofs - istep );        active_queue = ws_min( active_queue, t );        m[-mstep] = IN_QUEUE;    &#125;    <span class="hljs-keyword">if</span>( m[mstep] == <span class="hljs-number">0</span> )    &#123;        c_diff( ptr, ptr + istep, t );        ws_push( t, mofs + mstep, iofs + istep );        active_queue = ws_min( active_queue, t );        m[mstep] = IN_QUEUE;    &#125;&#125;</code></pre><h3 id="3-重复-2-直到所有队列为空"><a href="#3-重复-2-直到所有队列为空" class="headerlink" title="3. 重复 2. 直到所有队列为空"></a>3. 重复 2. 直到所有队列为空</h3><h2 id="其他定义"><a href="#其他定义" class="headerlink" title="其他定义"></a>其他定义</h2><pre><code class="hljs c++"><span class="hljs-comment">// A node represents a pixel to label</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">WSNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> next;    <span class="hljs-keyword">int</span> mask_ofs;    <span class="hljs-keyword">int</span> img_ofs;&#125;;<span class="hljs-comment">// Queue for WSNodes</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">WSQueue</span></span><span class="hljs-class">&#123;</span>    WSQueue() &#123; first = last = <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">int</span> first, last;&#125;;<span class="hljs-comment">// Create a new node with offsets mofs and iofs in queue idx</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ws_push(idx,mofs,iofs)          \</span>&#123;                                       \    <span class="hljs-keyword">if</span>( !free_node )                    \        free_node = allocWSNodes( storage );\    node = free_node;                   \    free_node = storage[free_node].next;\    storage[node].next = <span class="hljs-number">0</span>;             \    storage[node].mask_ofs = mofs;      \    storage[node].img_ofs = iofs;       \    <span class="hljs-keyword">if</span>( q[idx].last )                   \        storage[q[idx].last].next=node; \    <span class="hljs-keyword">else</span>                                \        q[idx].first = node;            \    q[idx].last = node;                 \&#125;<span class="hljs-comment">// Get next node from queue idx</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ws_pop(idx,mofs,iofs)           \</span>&#123;                                       \    node = q[idx].first;                \    q[idx].first = storage[node].next;  \    <span class="hljs-keyword">if</span>( !storage[node].next )           \        q[idx].last = <span class="hljs-number">0</span>;                \    storage[node].next = free_node;     \    free_node = node;                   \    mofs = storage[node].mask_ofs;      \    iofs = storage[node].img_ofs;       \&#125;<span class="hljs-comment">// 得到三个通道差值中的最大值，作为该像素的梯度值</span><span class="hljs-comment">// Get highest absolute channel difference in diff</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> c_diff(ptr1,ptr2,diff)           \</span>&#123;                                        \    db = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">abs</span>((ptr1)[<span class="hljs-number">0</span>] - (ptr2)[<span class="hljs-number">0</span>]);\    dg = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">abs</span>((ptr1)[<span class="hljs-number">1</span>] - (ptr2)[<span class="hljs-number">1</span>]);\    dr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">abs</span>((ptr1)[<span class="hljs-number">2</span>] - (ptr2)[<span class="hljs-number">2</span>]);\    diff = ws_max(db,dg);                \    diff = ws_max(diff,dr);              \    assert( <span class="hljs-number">0</span> &lt;= diff &amp;&amp; diff &lt;= <span class="hljs-number">255</span> );  \&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/153085246" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/153085246</a><br>watershed文档：<a href="https://docs.opencv.org/master/d2/dbd/tutorial_distance_transform.html" target="_blank" rel="noopener">https://docs.opencv.org/master/d2/dbd/tutorial_distance_transform.html</a><br>watershed示例：<a href="https://github.com/opencv/opencv/blob/bea2c7545243ba2dabce6badc94dd55894a8e5ca/samples/cpp/watershed.cpp" target="_blank" rel="noopener">https://github.com/opencv/opencv/blob/bea2c7545243ba2dabce6badc94dd55894a8e5ca/samples/cpp/watershed.cpp</a><br>watershed源码：<a href="https://github.com/opencv/opencv/blob/808ba552c532408bddd5fe51784cf4209296448a/modules/imgproc/src/segmentation.cpp" target="_blank" rel="noopener">https://github.com/opencv/opencv/blob/808ba552c532408bddd5fe51784cf4209296448a/modules/imgproc/src/segmentation.cpp</a>  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用clash无法连接到互联网的解决方法</title>
    <link href="/2020/10/24/%E4%BD%BF%E7%94%A8clash%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2020/10/24/%E4%BD%BF%E7%94%A8clash%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>使用clash无法连接到互联网有多种情况  </p><ol><li><p>端口占用  </p><blockquote><p>clash端口端口被占用，导致clash内核无法启动。（clash端口占用的原因目前尚不了解）<br> 可以通过<strong>重新设置clash端口</strong>解决。</p></blockquote></li></ol><p><img src="/image/clash_cfg_safe.jpg" srcset="/img/loading.gif" alt="config">  </p><ol start="2"><li><p>时间不同</p><blockquote><p>当linux切换到windows时，系统时间会错乱。由于代理协议需要保证本地时间准确，因此时间错乱时clash将无法使用。<br> 可以通过<strong>同步时间</strong>解决  </p></blockquote></li><li><p>其他原因</p><blockquote><p>如服务器故障、“网络升级”等导致。</p></blockquote></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Github网络问题</title>
    <link href="/2020/10/23/Github%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/10/23/Github%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>如果Github在使用的过程中出现了443或22等错误，可以通过一下方式解决：</p><ol><li><p>设置全局代理</p> <pre><code class="hljs sh">git config --global http.proxy http://127.0.0.1:9666</code></pre></li><li><p>修改HOSTS</p><p> 前往 <a href="https://github.com/kelthuzadx/hosts" target="_blank" rel="noopener">https://github.com/kelthuzadx/hosts</a> 或 <a href="https://travis-ci.org/github/googlehosts/hosts" target="_blank" rel="noopener">https://travis-ci.org/github/googlehosts/hosts</a>  </p><p> 更新 <a href="file:///C:/Windows/System32/drivers/etc/HOSTS">file:///C:/Windows/System32/drivers/etc/HOSTS</a>  </p></li><li><p>修改./ssh/config  </p> <pre><code class="hljs txt">Host github.com  User git  Hostname ssh.github.com  PreferredAuthentications publickey  IdentityFile ~&#x2F;.ssh&#x2F;id_rsa  Port 443</code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>上海</title>
    <link href="/2020/10/01/%E4%B8%8A%E6%B5%B7/"/>
    <url>/2020/10/01/%E4%B8%8A%E6%B5%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="上海交大华为云无人车比赛"><a href="#上海交大华为云无人车比赛" class="headerlink" title="上海交大华为云无人车比赛"></a>上海交大华为云无人车比赛</h2><h3 id="ROS节点主函数模板"><a href="#ROS节点主函数模板" class="headerlink" title="ROS节点主函数模板"></a>ROS节点主函数模板</h3><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    rospy.init_node(<span class="hljs-string">'node'</span>, anonymous=<span class="hljs-literal">True</span>)    rate = rospy.Rate(rate)    <span class="hljs-comment"># 使用try...expect结构，防止程序异常停止；</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># 实现ROS功能与类功能分离，便于调试；</span>        main = Class()        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():            <span class="hljs-keyword">try</span>:                main.spin()            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                traceback.print_exc()            rate.sleep()    <span class="hljs-keyword">except</span> rospy.ROSInterruptException:        print(rospy.ROSInterruptException)</code></pre><p>（整理中）</p><p><img src="/image/shanghai.jpg" srcset="/img/loading.gif" alt="climber">  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>彩虹</title>
    <link href="/2020/08/17/%E5%BD%A9%E8%99%B9/"/>
    <url>/2020/08/17/%E5%BD%A9%E8%99%B9/</url>
    
    <content type="html"><![CDATA[<p>在森林里<br>遇见了彩虹~</p><p><img src="/image/rainbow.jpg" srcset="/img/loading.gif" alt="rainbow">  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>登山</title>
    <link href="/2020/08/13/%E7%99%BB%E5%B1%B1/"/>
    <url>/2020/08/13/%E7%99%BB%E5%B1%B1/</url>
    
    <content type="html"><![CDATA[<p>留念<br>本网站建于2020.8.13  </p><p><img src="/image/climber.jpg" srcset="/img/loading.gif" alt="climber">  </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
